/*
 * encryption.c - Encryption handling
 *                Diffie Hellman
 *                AES mode CBC
 *
 *              Omer Kfir (C)
 */
#include "encryption.h"
#include "headers.h"

#include <crypto/hash.h>
#include <linux/crypto.h>
#include <linux/limits.h> // For UINT_MAX
#include <linux/random.h> // Getting random generated bytes
#include <linux/scatterlist.h>

// Generates random numbers in a certain range
unsigned int randint(unsigned int start, unsigned int end) {
  if (start >= end)
    return start;

  unsigned int random, range = end - start + 1;

  // Ensures no bias
  do {
    get_random_bytes(&random, sizeof(random));
  } while (random >= (UINT_MAX - (UINT_MAX % range)));

  return (random % range) + start;
}

// Pow function, math pow
unsigned int mod_pow(unsigned int base, unsigned int exp, unsigned int mod) {
  unsigned int result = 1;
  base = base % mod;

  while (exp > 0) {
    if (exp & 1)
      result = (result * base) % mod;

    exp = exp >> 1;
    base = (base * base) % mod;
  }

  return result;
}

/*
 * Diffie hellman key exchange related functions
 * AES (CBC) implementation
 */
struct {
  unsigned int g;
  unsigned int p;

  unsigned int private_key;
  unsigned int public_key;
} diffie;

struct {
  u8 key[KEY_MODE];
  u8 iv[KEY_MODE / 2];
} aesCBC;

void generate_diffie_numbers() {
  diffie.g = randint(2, 10);
  diffie.p = randint(10, 25);
  diffie.private_key = randint(2, 20);

  diffie.public_key = mod_pow(diffie.g, diffie.private_key, diffie.p);
}

void get_g_p(unsigned int *g, unsigned int *p) {
  *g = diffie.g;
  *p = diffie.p;
}

bool get_shared_secret(unsigned int other_public_key) {
  unsigned int shared_secret;
  shared_secret = mod_pow(other_public_key, diffie.private_key, diffie.p);

  return derive_key_from_secret(shared_secret, aesCBC.key) == 0;
}

int derive_key_from_secret(unsigned int shared_secret, u8 *key) {
  struct crypto_shash *tfm;
  struct shash_desc *desc;
  u8 shared_secret_bytes[sizeof(unsigned int)];
  int ret;

  // Convert the integer to bytes (little endian)
  for (int i = 0; i < sizeof(unsigned int); i++)
    shared_secret_bytes[i] = (shared_secret >> (i * 8)) & 0xFF;

  // Initialize SHA-256 algorithm
  tfm = crypto_alloc_shash("sha256", 0, 0);
  if (IS_ERR(tfm))
    return PTR_ERR(tfm);

  // Allocate descriptor for hashing operation
  desc = kmalloc(sizeof(struct shash_desc) + crypto_shash_descsize(tfm),
                 GFP_KERNEL);
  if (!desc) {
    crypto_free_shash(tfm);
    return -ENOMEM;
  }

  desc->tfm = tfm;

  // Perform hashing
  ret = crypto_shash_init(desc);
  if (ret)
    goto out;

  ret = crypto_shash_update(desc, shared_secret_bytes,
                            sizeof(shared_secret_bytes));
  if (ret)
    goto out;

  // Get hash result (SHA-256 always produces 32 bytes)
  ret = crypto_shash_final(desc, key);

out:
  kfree(desc);
  crypto_free_shash(tfm);
  return ret;
}

static size_t pkcs7_pad(const u8 *data, size_t len, size_t block_size,
                        u8 *padded_data) {
  size_t padding_len = block_size - (len % block_size);
  size_t padded_len = len + padding_len;

  /* Copy original data */
  memcpy(padded_data, data, len);

  /* Add padding bytes - each byte is set to the padding length value */
  memset(padded_data + len, padding_len, padding_len);
  return padded_len;
}

static int aes_cbc_encrypt_padded(const u8 *data_in, size_t data_len,
                                  u8 *data_out, size_t *out_len) {
  struct crypto_skcipher *tfm;
  struct skcipher_request *req;
  struct scatterlist sg_in, sg_out;
  struct crypto_wait wait;
  u8 *padded_data;
  size_t padded_len;
  int ret;

  /* Generate random IV */
  get_random_bytes(aesCBC.iv, sizeof(aesCBC.iv));

  /* Copy IV to the beginning of the output buffer */
  memcpy(data_out, aesCBC.iv, sizeof(aesCBC.iv));

  /* Calculate padded length and allocate padded buffer */
  padded_len = data_len + (BLOCK_SIZE - (data_len % BLOCK_SIZE));
  padded_data = kmalloc(padded_len, GFP_KERNEL);
  if (!padded_data) {
    printk(KERN_INFO "Failed to allocate padded data buffer\n");
    return -ENOMEM;
  }

  /* Apply PKCS#7 padding */
  padded_len = pkcs7_pad(data_in, data_len, BLOCK_SIZE, padded_data);

  /* Allocate cipher handle - AES-256-CBC */
  tfm = crypto_alloc_skcipher("cbc(aes)", 0, 0);
  if (IS_ERR(tfm)) {
    printk(KERN_INFO "Failed to allocate cipher handle\n");
    ret = PTR_ERR(tfm);
    goto free_padded;
  }

  /* Set key - 32 bytes for AES-256 */
  ret = crypto_skcipher_setkey(tfm, aesCBC.key, KEY_MODE);
  if (ret) {
    printk(KERN_INFO "Failed to set key: %d\n", ret);
    goto free_tfm;
  }

  /* Initialize request */
  req = skcipher_request_alloc(tfm, GFP_KERNEL);
  if (!req) {
    printk(KERN_INFO "Failed to allocate request\n");
    ret = -ENOMEM;
    goto free_tfm;
  }

  /* Initialize wait */
  crypto_init_wait(&wait);

  /* Setup scatterlists */
  sg_init_one(&sg_in, padded_data, padded_len);
  sg_init_one(&sg_out, data_out + sizeof(aesCBC.iv), padded_len);

  /* Setup request */
  skcipher_request_set_callback(
      req, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,
      crypto_req_done, &wait);
  skcipher_request_set_crypt(req, &sg_in, &sg_out, padded_len, aesCBC.iv);

  /* Perform encryption */
  ret = crypto_wait_req(crypto_skcipher_encrypt(req), &wait);
  if (ret) {
    printk(KERN_INFO "Encryption failed: %d\n", ret);
    goto free_req;
  }

  /* Set output length = IV length + ciphertext length */
  *out_len = sizeof(aesCBC.iv) + padded_len;

free_req:
  skcipher_request_free(req);
free_tfm:
  crypto_free_skcipher(tfm);
free_padded:
  kfree(padded_data);
  return ret;
}